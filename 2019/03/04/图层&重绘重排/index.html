<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/ChinaZhaoyuxuan.github.io/css/style.css">
  
    <link rel="stylesheet" href="/ChinaZhaoyuxuan.github.io/fancybox/jquery.fancybox.min.css">
  
  <script src="/ChinaZhaoyuxuan.github.io/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-图层&amp;重绘重排" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    

    
      <div class="article-meta">
        <a href="/ChinaZhaoyuxuan.github.io/2019/03/04/图层&重绘重排/" class="article-date">
  <time datetime="2019-03-04T11:45:08.158Z" itemprop="datePublished">2019-03-04</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>###css图层<br>    浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。<br>    在渲染DOM的时候，浏览器所做的工作实际上是：</p>
<pre><code>1. 获取DOM后分割为多个图层
2. 对每个图层的节点计算样式结果        （Recalculate style--样式重计算）
3. 为每个节点生成图形和位置            （Layout--重排,回流）
4. 将每个节点绘制填充到图层位图中        （Paint--重绘）
5. 图层作为纹理上传至GPU
6. 符合多个图层到页面上生成最终屏幕图像    （Composite Layers--图层重组）
</code></pre><p>###图层创建的条件<br>    Chrome中满足以下任意情况就会创建图层：</p>
<pre><code>1. 拥有具有3D变换的CSS属性
2. 使用加速视频解码的&lt;video&gt;节点
3. &lt;canvas&gt;节点
4. CSS3动画的节点
5. 拥有CSS加速属性的元素(will-change)
</code></pre><p>###重绘(Repaint)<br>    重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，<br>    使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</p>
<pre><code>需要注意的是：重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。
比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。
所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0)
CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）
</code></pre><p>###重排(Reflow 回流)<br>    渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排</p>
<pre><code>&quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。
 但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。
</code></pre><p>###触发重绘的属性</p>
<pre><code>* color                                * background                                    * outline-color
* border-style                        * background-image                                * outline
* border-radius                        * background-position                            * outline-style
* visibility                        * background-repeat                                * outline-width
* text-decoration                    * background-size                                * box-shadow
</code></pre><p>###触发重排(回流)的属性<br>    盒子模型相关属性会触发重布局            定位属性及浮动也会触发重布局：                改变节点内部文字结构也会触发重布局：</p>
<pre><code>* width                                * top                                            * text-align
* height                            * bottom                                        * overflow-y
* padding                            * left                                            * font-weight
* margin                            * right                                            * overflow
* display                            * position                                        * font-family
* border-width                        * float                                            * line-height
* border                            * clear                                            * vertival-align
* min-height                                                                        * white-space
</code></pre><p>###常见的触发重排的操作<br>    Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，<br>    一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，<br>    但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。</p>
<pre><code>所以，下面这些动作有很大可能会是成本比较高的。
    当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。
    当你移动 DOM 的位置
    当你修改 CSS 样式的时候。
    当你 Resize 窗口的时候（移动端没有这个问题，因为移动端的缩放没有影响布局视口）
    当你修改网页的默认字体时。
    获取某些属性时(width,height...)
    注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。
</code></pre><p>###优化方案<br>    如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的工作（减少1234中的步骤）</p>
<pre><code>    1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算）
    2. 为每个节点生成图形和位置（Layout--回流和重布局）
    3. 将每个节点填充到图层中（Paint Setup和Paint--重绘）
    4. 组合图层到页面上（Composite Layers--图层重组）

1.元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作
    变换（transform）和透明度（opacity）的改变仅仅影响图层的组合
2.使用opacity来代替visibility
    (1).使用visibility不触发重排，但是依然重绘。
    (2).直接使用opacity即触发重绘，又触发重排（就是这样设计的！！！）。
    (3).opacity配合图层使用，即不触发重绘也不触发重排。
        原因：
        透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。
        不过这个前提是这个被修改opacity本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化
3.不要使用table布局
    table-cell
4.将多次改变样式属性的操作合并成一次操作
    不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className
5.将DOM离线后再修改
    由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。
    如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。
6.利用文档碎片(documentFragment)
7.不要把某些DOM节点的属性值放在一个循环里当成循环的变量
    当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：
        1. offsetTop, offsetLeft, offsetWidth, offsetHeight
        2. scrollTop/Left/Width/Height
        3. clientTop/Left/Width/Height
        4. width,height
    当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，
    因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，
    浏览器都会强行刷新渲染队列。
8.动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)
</code></pre><p>###requestAnimationFrame<br>     window.requestAnimationFrame()<br>        window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画<br>        该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>
<pre><code>回调函数会被传入一个参数，DOMHighResTimeStamp，指示requestAnimationFrame() 开始触发回调函数的当前时间

返回值
    一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。
    你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。

window.cancelAnimationFrame(requestID)
     取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求.
     requestID是先前调用window.requestAnimationFrame()方法时返回的ID.
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/ChinaZhaoyuxuan/ChinaZhaoyuxuan.github.io/2019/03/04/图层&重绘重排/" data-id="cjsua5pce0002x0vfuekfbbcb" class="article-share-link">Share</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
    
      <a href="/ChinaZhaoyuxuan.github.io/2019/03/04/渲染引擎&阻塞/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title"></div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 Hexo</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
      <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/ChinaZhaoyuxuan.github.io/"><img src="/images/hexo.svg" alt="Hexo"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/ChinaZhaoyuxuan.github.io/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/ChinaZhaoyuxuan.github.io/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/ChinaZhaoyuxuan.github.io/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/ChinaZhaoyuxuan.github.io/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/ChinaZhaoyuxuan.github.io/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/ChinaZhaoyuxuan.github.io/js/jquery-2.0.3.min.js"></script>
<script src="/ChinaZhaoyuxuan.github.io/js/lazyload.min.js"></script>
<script src="/ChinaZhaoyuxuan.github.io/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/ChinaZhaoyuxuan.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/ChinaZhaoyuxuan.github.io/js/ocean.js"></script>

</body>
</html>